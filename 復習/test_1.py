"""
幅優先探索（BFS）
全てのノードを探索したい場合に、幅優先探索は探索を開始する頂点からの深さが等しくなるように進んでいく方式。
距離1を全て調べ、距離2を全て調べ・・・という手順を繰り返し最深部まで探索していく。
最も最初に追加された候補を優先的に探索する方式で進むノードを決定するため、データ構造としてはFirst-In-First-Outであるキューを用いるのが適している。
"""
N,M = map(int,input().split())
G = [[] for _ in range(N)]
for i in range(M):
  A,B = map(int,input().split())
  A -= 1
  B -= 1
  G[A].append(B)
  G[B].append(A)

#初期化
que = [0] # 頂点から順にappendしていく
dist = [None]*N # 頂点=都市1からの距離。[都市1から都市1への距離, 都市1から都市2への距離,,,,,都市1から都市Nへの距離]
cnt = [0]*N # 頂点=都市1からの最短経路の数。[都市1から都市1への最短経路の数, 都市1から都市2への最短経路の数,,,,,都市1から都市Nへの最短経路の数]
dist[0] = 0 # 都市1から都市1への距離は0
cnt[0] = 1 # 都市1から都市1への最短経路は1個

#BFS queにまず入っている頂点を取り出し、その子nodeリストであるG[v]の中を探索。G[v]から取り出した子nodeであるvvをqueへappend。
for v in que: # vを取り出すタイミング = 一つ深い階層へ進むこと
  for vv in G[v]: # G[v]の中のvvを順番に探索 = 幅方向の探索。幅方向の探索が済んでから深い階層へ進むので幅優先探索となっている。
    if dist[vv] is None: # 未探索の場合
      dist[vv] = dist[v] + 1 # 親nodeであるvに1を足す
      que.append(vv) # 探索したvvをqueへ格納
      cnt[vv] = cnt[v]
    elif dist[vv] == dist[v] + 1: # 新たに最短経路が見つかった場合
      cnt[vv] += cnt[v] # これまでの最短経路数cnt[v]を足し合わす
      cnt[vv] %= 1000000007

print(cnt[N-1])