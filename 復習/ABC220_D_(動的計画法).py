"""
出力イメージ（入力例1の場合）
初期値→[0,0,1,0,0,0,0,0,0,0] 2が左端にあるので配列の要素2に1立てる = 1件存在するという意味
1回目の処理後→[0,0,0,0,1,0,0,0,0,1] 2に対する操作F(2+7)で9が、操作G(2*7)で4が出現するので、要素4と9に1立てる
2回目の処理後→[1,0,0,0,2,1,0,0,0,0] 4に対する操作F(4+6)で0、操作G(4*6)で4、9に対する操作F(9+6)で5、操作G(9*6)で4が出現するので、要素0に1、要素4に2、要素5に1を立てる
"""

N = int(input())
A = list(map(int,input().split()))
A = [-1] + A # indexと数値が合うように先頭にダミーを挿入
mod = 998244353

#    ダミー                                                           初期値 1回目の処理後  2        N-1回目の処理後=答え
# [[左端が0となったケース数,..1となったケース数,,,,9となったケース数],[,,,,],[,,,,,,,,],,,[,,,,,,,,],,,,[,,,,,,,,,,]]
dp = [[0]*10 for _ in range(N+1)]
# 初期値 左端はA[1]であり1ケースあり
dp[1][A[1]] = 1

# N-1回の操作F及び操作Gを行う。操作F、G両方の処理結果を同じ配列に反映させてしまう
for i in range(1,N):
  for j in range(0,10): # 0～9のすべての数値で操作F、Gを実施。
    dp[i+1][(j+A[i+1])%10] += dp[i][j] # 操作F
    dp[i+1][(j+A[i+1])%10] %= mod # 数値小さくしてオーバーフロウと計算時間短縮対策
    dp[i+1][(j*A[i+1])%10] += dp[i][j] # 操作G
    dp[i+1][(j*A[i+1])%10] %= mod # 数値小さくしてオーバーフロウと計算時間短縮対策

# 答え出力
for i in range(10):
  print(dp[N][i]%mod)